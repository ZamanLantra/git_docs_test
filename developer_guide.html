

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Developer Guide &mdash; OP-PIC 0.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=2709fde1"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="OP-PIC C++ API" href="api.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            OP-PIC
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">OP-PIC C++ API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Developer Guide</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#example-application">Example Application</a></li>
<li class="toctree-l2"><a class="reference internal" href="#original-load-mesh-and-initialization">Original - Load mesh and initialization</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-1-preparing-to-use-op-pic">Step 1 - Preparing to use OP-PIC</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-2-op-pic-declaration">Step 2 - OP-PIC Declaration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-declare-sets">(a) Declare sets</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-declare-maps">(b) Declare maps</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-declare-data">(c) Declare data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#d-declare-constants">(d) Declare constants</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#step-3-parallel-loop-opp-par-loop">Step 3 - Parallel loop : <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code></a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-direct-loop">(a) Direct loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-indirect-loop-single-indirection">(b) Indirect loop (single indirection)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-double-indirect-loop">(c) Double Indirect loop</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#step-4-move-loop-opp-particle-move">Step 4 - Move loop : <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code></a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-5-particle-injections">Step 5 - Particle injections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-allocate-space-for-particles">(a) Allocate space for particles</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-initialize-the-injected-particles">(b) Initialize the injected particles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#step-6-global-reductions">Step 6 - Global reductions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-7-handing-it-all-to-op-pic">Step 7 - Handing it all to OP-PIC</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#a-distributing-data-over-mpi-ranks">(a) Distributing data over MPI ranks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#b-partitioning-data-over-mpi-ranks">(b) Partitioning data over MPI ranks</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#step-8-code-generation">Step 8 - Code generation</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">OP-PIC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Developer Guide</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/developer_guide.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="developer-guide">
<h1>Developer Guide<a class="headerlink" href="#developer-guide" title="Link to this heading"></a></h1>
<p>This page provides a tutorial in the basics of using OP-PIC for unstructured-mesh PIC application development.</p>
<section id="example-application">
<h2>Example Application<a class="headerlink" href="#example-application" title="Link to this heading"></a></h2>
<p>The tutorial will use the FemPIC application, an electrostatic 3D unstructured mesh finite element PIC code (<a class="reference external" href="https://github.com/ExCALIBUR-NEPTUNE/Documents/blob/main/reports/2057699/TN-03-3.pdf">https://github.com/ExCALIBUR-NEPTUNE/Documents/blob/main/reports/2057699/TN-03-3.pdf</a>).</p>
<p>It is based on tetrahedral mesh cells, nodes and faces forming a duct.
Faces on one end of the duct are designated as inlet faces and the outer wall is fixed at a higher potential to retain the ions within the duct.
Charged particles are injected at a constant rate from the inlet faces of the duct (one-stream) at a fixed velocity, and the particles move through the duct under the influence of the electric field.
The particles are removed when they leave the boundary face. Overall Mini-FEM-PIC has 1 degree of freedom (DOF) per cell, 2 DOFs per node and 7 DOFs per particle.</p>
<p>FemPIC consists of six main loops, <code class="docutils literal notranslate"><span class="pre">inject_ions</span></code> , <code class="docutils literal notranslate"><span class="pre">calculate_new_pos_vel</span></code> , <code class="docutils literal notranslate"><span class="pre">move</span></code> , <code class="docutils literal notranslate"><span class="pre">deposit_charge_on_nodes</span></code>, <code class="docutils literal notranslate"><span class="pre">compute_node_charge_density</span></code> and <code class="docutils literal notranslate"><span class="pre">compute_electric_field</span></code>, within a time-marching iterative loop.
Additionally, it contains a <code class="docutils literal notranslate"><span class="pre">init_boundary_pot</span></code> loop and a <code class="docutils literal notranslate"><span class="pre">get_final_max_values</span></code> loop used during initialzing and finalizing stages.
In addition to the above loops, FemPIC consists of a linear sparse matrix field solver, which is implemented using PETSc library.</p>
<p>Out of these, <code class="docutils literal notranslate"><span class="pre">compute_node_charge_density</span></code>, <code class="docutils literal notranslate"><span class="pre">init_boundary_pot</span></code> and <code class="docutils literal notranslate"><span class="pre">get_final_max_values</span></code> are what we classify as direct loops where all the data accessed in the loop is defined on the mesh element over which the loop iterates over.
Thus, for example in a direct loop, a loop over nodes will only access data defined on nodes.</p>
<p>All the other loops are indirect loops.
In this case when looping over a given type of elements, data on other types of elements will be accessed indirectly, using mapping tables.
There are two types of indirect loops.
The <code class="docutils literal notranslate"><span class="pre">compute_electric_field</span></code> loop iterates over cells and read data on nodes, accessing them indirectly via a mapping table that gives the explicit connectivity information between cells and nodes.
Similarly, <code class="docutils literal notranslate"><span class="pre">calculate_new_pos_vel</span></code> loop iterates over particles and read data on cells, accessing them indirectly via a mapping between particles and cells.
The other kind of indirect loop is double-indirect.
For example, <code class="docutils literal notranslate"><span class="pre">deposit_charge_on_nodes</span></code> loop iterates over particles and increments data on nodes. But these nodes are not directly related to particles though one mapping.
Thus, we may need to use two mappings, the first from particles to cells (p2c_map) and the second from cells to nodes (c2n_map).</p>
<p>Within these above mentioned loop, there is a special loop which will move particles to cells according to the particle position, and the further details will be discussed in a later section.</p>
<ul class="simple">
<li><p>Go to the <code class="docutils literal notranslate"><span class="pre">OP-PIC/app_fempic</span></code> directory and open the <code class="docutils literal notranslate"><span class="pre">fempic.cpp</span></code> file to view the original application.</p></li>
<li><p>Use the information in the readme file of that directory to code-generate and run the application.</p></li>
</ul>
</section>
<section id="original-load-mesh-and-initialization">
<h2>Original - Load mesh and initialization<a class="headerlink" href="#original-load-mesh-and-initialization" title="Link to this heading"></a></h2>
<p>The original code begins with allocating memory to hold the mesh data and then initializing them by reading in the mesh data, form the text file.</p>
<p>In this tutorial, the main focus is to show how the OP-PIC API is used, hence the user may implement their own code for mesh loading.</p>
<p>Go to the <code class="docutils literal notranslate"><span class="pre">OP-PIC/app_fempic/fempic_misc_mesh_loader.h</span></code> to see the complete mesh loader, where we use the original Mini-FEM-PIC code to read from file and store in the data storage class <code class="docutils literal notranslate"><span class="pre">DataPointers</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">DataPointers</span><span class="o">&gt;</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">load_mesh</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="step-1-preparing-to-use-op-pic">
<h2>Step 1 - Preparing to use OP-PIC<a class="headerlink" href="#step-1-preparing-to-use-op-pic" title="Link to this heading"></a></h2>
<p>First, include the following header files, then initialize OP-PIC and finalize it as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opp_templates.h&quot;</span>
<span class="p">...</span>
<span class="p">...</span>
<span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">**</span><span class="n">argv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">opp_init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span><span class="w"> </span><span class="n">argv</span><span class="p">);</span><span class="w"> </span><span class="c1">//Initialise the OP-PIC library, passing runtime args</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">opp_exit</span><span class="p">();</span><span class="w"> </span><span class="c1">//Finalising the OP-PIC library</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="step-2-op-pic-declaration">
<h2>Step 2 - OP-PIC Declaration<a class="headerlink" href="#step-2-op-pic-declaration" title="Link to this heading"></a></h2>
<section id="a-declare-sets">
<h3>(a) Declare sets<a class="headerlink" href="#a-declare-sets" title="Link to this heading"></a></h3>
<p>The FemPIC application consists of three mesh element types (which we call sets): <code class="docutils literal notranslate"><span class="pre">cells</span></code>, <code class="docutils literal notranslate"><span class="pre">nodes</span></code>, and <code class="docutils literal notranslate"><span class="pre">inlet-faces</span></code>.
These needs to be declared using the <code class="docutils literal notranslate"><span class="pre">opp_decl_set</span></code> API call together with the number of elements for each of these sets.</p>
<p>In addition, FemPIC contains a particle set, that is defined using <code class="docutils literal notranslate"><span class="pre">opp_decl_particle_set</span></code> API call together with the number of particles and a mesh cell set.</p>
<p>The speciality of a particle set is that they can be resized (the set size can be increased or reduced during the simulation).
Other than the main particle set, we have used a temporary dummy particle set to hold some random data for particle injection initialization.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">// declare sets</span>
<span class="n">opp_set</span><span class="w"> </span><span class="n">node_set</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_set</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">n_nodes</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mesh_nodes&quot;</span><span class="p">);</span>
<span class="n">opp_set</span><span class="w"> </span><span class="n">cell_set</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_set</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">n_cells</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mesh_cells&quot;</span><span class="p">);</span>
<span class="n">opp_set</span><span class="w"> </span><span class="n">iface_set</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_set</span><span class="p">(</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">n_ifaces</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;inlet_faces_cells&quot;</span><span class="p">);</span>
<span class="n">opp_set</span><span class="w"> </span><span class="n">particle_set</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_particle_set</span><span class="p">(</span><span class="s">&quot;particles&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cell_set</span><span class="p">);</span>
<span class="n">opp_set</span><span class="w"> </span><span class="n">dummy_part_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_particle_set</span><span class="p">(</span><span class="s">&quot;dummy particles&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cell_set</span><span class="p">);</span>
</pre></div>
</div>
<p>Later, we will see how the number of mesh elements can be read in directly from an hdf5 file using the <code class="docutils literal notranslate"><span class="pre">opp_decl_set_hdf5</span></code> and <code class="docutils literal notranslate"><span class="pre">opp_decl_particle_set_hdf5</span></code> call.</p>
<p>When developing your own application with OP-PIC, or indeed converting an application to use OP-PIC, you will need to decide on what mesh element types, i.e. sets will need to be declared to define the full mesh.
A good starting point for this design is to see what mesh elements are used the loops over the mesh.</p>
</section>
<section id="b-declare-maps">
<h3>(b) Declare maps<a class="headerlink" href="#b-declare-maps" title="Link to this heading"></a></h3>
<p>Looking at the original Mini-FEM-PIC application’s loops we see that mappings between cells and nodes, cells and cells, inlet-faces and nodes, inlet-faces and cells, and cells and nodes are required.
In addition, a particles to cells mapping is required.</p>
<p>This can be observed by the indirect access to data in each of the loops in the main iteration loops.
These connectivity information needs to be declared via the <code class="docutils literal notranslate"><span class="pre">opp_decl_map</span></code> API call:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//declare maps</span>
<span class="n">opp_map</span><span class="w"> </span><span class="n">c2n_map</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w">  </span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">c_to_n</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_v_n_map&quot;</span><span class="p">);</span>
<span class="n">opp_map</span><span class="w"> </span><span class="n">c2c_map</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w">  </span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">c_to_c</span><span class="p">,</span><span class="w">  </span><span class="s">&quot;c_v_c_map&quot;</span><span class="p">);</span>
<span class="n">opp_map</span><span class="w"> </span><span class="n">if2c_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">if_to_c</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;if_v_c_map&quot;</span><span class="p">);</span>
<span class="n">opp_map</span><span class="w"> </span><span class="n">if2n_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">if_to_n</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;if_v_n_map&quot;</span><span class="p">);</span>

<span class="n">opp_map</span><span class="w"> </span><span class="n">p2c_map</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map</span><span class="p">(</span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;p2c_map&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">opp_decl_map</span></code> requires the names of the two sets for which the mapping is declared, its arity, mapping data (as in this case allocated in integer blocks of memory) and a string name.
A map created with a particle set is capable of changing its length during the simulation and other maps are static.</p>
<p>Note that we have declared <code class="docutils literal notranslate"><span class="pre">p2c_map</span></code> with a <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> since <code class="docutils literal notranslate"><span class="pre">particle_set</span></code> is defined without a particle count (i.e. zero), since we anticipate injecting particles during the simulation.</p>
</section>
<section id="c-declare-data">
<h3>(c) Declare data<a class="headerlink" href="#c-declare-data" title="Link to this heading"></a></h3>
<p>All data declared on sets should be declared using the <code class="docutils literal notranslate"><span class="pre">opp_decl_dat</span></code> API call. For FemPIC this consists of seven cell dats, six node dats, six inlet-face dats and three particle dats (+1 dummy particle dat).</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//declare data on sets</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">c_det</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">c_det</span><span class="p">,</span><span class="w">      </span><span class="s">&quot;c_det&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">c_volume</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">c_vol</span><span class="p">,</span><span class="w">      </span><span class="s">&quot;c_volume&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">c_ef</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">c_ef</span><span class="p">,</span><span class="w">       </span><span class="s">&quot;c_ef&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">c_sd</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">c_sd</span><span class="p">,</span><span class="w">       </span><span class="s">&quot;c_shape_deri&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">c_gbl_id</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_INT</span><span class="p">,</span><span class="w">  </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">c_id</span><span class="p">,</span><span class="w">       </span><span class="s">&quot;c_gbl_id&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">c_colors</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_INT</span><span class="p">,</span><span class="w">  </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">c_col</span><span class="p">,</span><span class="w">      </span><span class="s">&quot;c_colors&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">c_centroids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">c_centroid</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_centroids&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">n_volume</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">n_vol</span><span class="p">,</span><span class="w">     </span><span class="s">&quot;n_vol&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">n_potential</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">n_pot</span><span class="p">,</span><span class="w">     </span><span class="s">&quot;n_potential&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">n_charge_den</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">n_ion_den</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;n_charge_den&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">n_pos</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">n_pos</span><span class="p">,</span><span class="w">     </span><span class="s">&quot;n_pos&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">n_type</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_INT</span><span class="p">,</span><span class="w">  </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">n_type</span><span class="p">,</span><span class="w">    </span><span class="s">&quot;n_type&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">n_bnd_pot</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">n_bnd_pot</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;n_bnd_pot&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">if_v_norm</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">if_v_norm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;iface_v_norm&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">if_u_norm</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">if_u_norm</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;iface_u_norm&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">if_norm</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">if_norm</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;iface_norm&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">if_area</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">if_area</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;iface_area&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">if_distrib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_INT</span><span class="p">,</span><span class="w">  </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">if_dist</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;iface_dist&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">if_n_pos</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">m</span><span class="o">-&gt;</span><span class="n">if_n_pos</span><span class="p">,</span><span class="w">  </span><span class="s">&quot;iface_n_pos&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">p_pos</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;p_position&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">p_vel</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;p_velocity&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">p_lc</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;p_lc&quot;</span><span class="p">);</span>

<span class="w">  </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">dp_rand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat</span><span class="p">(</span><span class="n">dummy_part_set</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dummy_part_rand&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that we have declared particle dats with a <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> since <code class="docutils literal notranslate"><span class="pre">particle_set</span></code> is defined without a particle count (i.e. zero), since we anticipate injecting particles during the simulation.</p>
</section>
<section id="d-declare-constants">
<h3>(d) Declare constants<a class="headerlink" href="#d-declare-constants" title="Link to this heading"></a></h3>
<p>Finally global constants that are used in any of the computations in the loops needs to be declared.
This is required due to the fact that when using code-generation later for parallelizations such as on GPUs (e.g. using CUDA or HIP), global constants need to be copied over to the GPUs before they can be used in a GPU kernel.</p>
<p>Declaring them using the <code class="docutils literal notranslate"><span class="pre">opp_decl_const&lt;type&gt;</span></code> API call will indicate to the OP-PIC code-generator that these constants need to be handled in a special way, generating code for copying them to the GPU for the relevant back-ends.
The template types could be <code class="docutils literal notranslate"><span class="pre">OPP_REAL</span></code>, <code class="docutils literal notranslate"><span class="pre">OPP_INT</span></code>, <code class="docutils literal notranslate"><span class="pre">OPP_BOOL</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//declare global constants</span>
<span class="n">opp_decl_const</span><span class="o">&lt;</span><span class="n">OPP_REAL</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">spwt</span><span class="p">,</span><span class="w">           </span><span class="s">&quot;CONST_spwt&quot;</span><span class="p">);</span>
<span class="n">opp_decl_const</span><span class="o">&lt;</span><span class="n">OPP_REAL</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ion_velocity</span><span class="p">,</span><span class="w">   </span><span class="s">&quot;CONST_ion_velocity&quot;</span><span class="p">);</span>
<span class="n">opp_decl_const</span><span class="o">&lt;</span><span class="n">OPP_REAL</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">dt</span><span class="p">,</span><span class="w">             </span><span class="s">&quot;CONST_dt&quot;</span><span class="p">);</span>
<span class="n">opp_decl_const</span><span class="o">&lt;</span><span class="n">OPP_REAL</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">plasma_den</span><span class="p">,</span><span class="w">     </span><span class="s">&quot;CONST_plasma_den&quot;</span><span class="p">);</span>
<span class="n">opp_decl_const</span><span class="o">&lt;</span><span class="n">OPP_REAL</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">mass</span><span class="p">,</span><span class="w">           </span><span class="s">&quot;CONST_mass&quot;</span><span class="p">);</span>
<span class="n">opp_decl_const</span><span class="o">&lt;</span><span class="n">OPP_REAL</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">charge</span><span class="p">,</span><span class="w">         </span><span class="s">&quot;CONST_charge&quot;</span><span class="p">);</span>
<span class="n">opp_decl_const</span><span class="o">&lt;</span><span class="n">OPP_REAL</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wall_potential</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CONST_wall_potential&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>The constants can be accessed in the kernels with the same literals used in the string name.
An example can be seen in the next section (Step 3).</p>
</section>
</section>
<section id="step-3-parallel-loop-opp-par-loop">
<h2>Step 3 - Parallel loop : <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code><a class="headerlink" href="#step-3-parallel-loop-opp-par-loop" title="Link to this heading"></a></h2>
<section id="a-direct-loop">
<h3>(a) Direct loop<a class="headerlink" href="#a-direct-loop" title="Link to this heading"></a></h3>
<p>We can now convert a direct loop to use the OP-PIC API.</p>
<p>We have chosen <code class="docutils literal notranslate"><span class="pre">compute_node_charge_density</span></code> to demostrate a direct loop.
It iterates over nodes, <code class="docutils literal notranslate"><span class="pre">multiply</span> <span class="pre">node_charge_den</span></code> with (<code class="docutils literal notranslate"><span class="pre">CONST_spwt</span></code> / <code class="docutils literal notranslate"><span class="pre">node_volume</span></code>) and saves to multiply <code class="docutils literal notranslate"><span class="pre">node_charge_den</span></code>.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//compute_node_charge_density : iterates over nodes</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">nnodes</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">iteration</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">node_charge_den</span><span class="p">[</span><span class="n">iteration</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="p">(</span><span class="n">CONST_spwt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">node_volume</span><span class="p">[</span><span class="n">iteration</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a direct loop due to the fact that all data accessed in the computation are defined on the set that the loop iterates over. In this case the iteration set is nodes.</p>
<p>To convert to the OP-PIC API we first outline the loop body (elemental kernel) to a subroutine:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">compute_ncd_kernel</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">ncd</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">nv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ncd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="p">(</span><span class="n">CONST_spwt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>
<span class="c1">//compute_node_charge_density : iterates over nodes</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iteration</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="p">(</span><span class="n">nnodes</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">iteration</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">compute_ncd_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">node_charge_den</span><span class="p">[</span><span class="n">iteration</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">node_volume</span><span class="p">[</span><span class="n">iteration</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now we can directly declare the loop with the <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> API call:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">compute_ncd_kernel</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">ncd</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">nv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ncd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="p">(</span><span class="n">CONST_spwt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">nv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="p">}</span>

<span class="n">opp_par_loop</span><span class="p">(</span><span class="n">compute_ncd_kernel</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;compute_node_charge_density&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_ITERATE_ALL</span><span class="p">,</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_charge_den</span><span class="p">,</span><span class="w">  </span><span class="n">OPP_RW</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_volume</span><span class="p">,</span><span class="w">      </span><span class="n">OPP_READ</span><span class="p">));</span>
</pre></div>
</div>
<p>Note how we have:</p>
<ul class="simple">
<li><p>indicated the elemental kernel <code class="docutils literal notranslate"><span class="pre">compute_ncd_kernel</span></code> in the first argument to <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code>.</p></li>
<li><p>used the <code class="docutils literal notranslate"><span class="pre">opp_dat``s</span> <span class="pre">names</span> <span class="pre">``n_charge_den</span></code> and <code class="docutils literal notranslate"><span class="pre">n_volume</span></code> in the API call.</p></li>
<li><p>noted the iteration set <code class="docutils literal notranslate"><span class="pre">node_set</span></code> (3rd argument) and iteration type <code class="docutils literal notranslate"><span class="pre">OPP_ITERATE_ALL</span></code> (4th argument).</p></li>
<li><p>indicated the direct access of <code class="docutils literal notranslate"><span class="pre">n_charge_den</span></code> and <code class="docutils literal notranslate"><span class="pre">n_volume</span></code> without any mappings provided to <code class="docutils literal notranslate"><span class="pre">opp_arg_dat</span></code>.</p></li>
<li><p>indicated that <code class="docutils literal notranslate"><span class="pre">n_volume</span></code> is read only (<code class="docutils literal notranslate"><span class="pre">OP_READ</span></code>) and <code class="docutils literal notranslate"><span class="pre">n_charge_den</span></code> is read &amp; write (<code class="docutils literal notranslate"><span class="pre">OPP_RW</span></code>), by looking through the elemental kernel and identifying how they are used/accessed in the kernel.</p></li>
<li><p>given that <code class="docutils literal notranslate"><span class="pre">n_volume</span></code> is read only we also indicate this by the key word <code class="docutils literal notranslate"><span class="pre">const</span></code> for <code class="docutils literal notranslate"><span class="pre">compute_ncd_kernel</span></code> elemental kernel.</p></li>
<li><p>note that we have accessed a const value <code class="docutils literal notranslate"><span class="pre">CONST_spwt</span></code> that we declared using <code class="docutils literal notranslate"><span class="pre">opp_decl_const&lt;OPP_REAL&gt;()</span></code> API call.</p></li>
</ul>
</section>
<section id="b-indirect-loop-single-indirection">
<h3>(b) Indirect loop (single indirection)<a class="headerlink" href="#b-indirect-loop-single-indirection" title="Link to this heading"></a></h3>
<p>We have selected two loops in FemPIC to demonstrate single indirections.</p>
<p>First, we use <code class="docutils literal notranslate"><span class="pre">compute_electric_field</span></code> calculation to showcase the mesh set to mesh set mapping indirections.
Here we iterate over cells set, access node potentials through indirect accesses using <code class="docutils literal notranslate"><span class="pre">c2n_map</span></code>.
Note that one cell in FemPIC is linked with 4 surrounding nodes and <code class="docutils literal notranslate"><span class="pre">n_potential</span></code> has a dimension of one.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//compute_electric_field : iterates over cells</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ncell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map1idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map2idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map3idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map4idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">c_ef</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ef</span><span class="p">[</span><span class="mi">12</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">-</span>
<span class="w">            </span><span class="p">((</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">12</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">)]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_potential</span><span class="p">[</span><span class="n">map1idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="p">(</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">12</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">)]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_potential</span><span class="p">[</span><span class="n">map2idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="p">(</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">12</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">6</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">)]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_potential</span><span class="p">[</span><span class="n">map3idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="p">(</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">12</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">9</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">)]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_potential</span><span class="p">[</span><span class="n">map4idx</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">])));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similar to the direct loop, we outline the loop body and call it within the loop as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">compute_ef_kernel</span><span class="p">(</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">c_ef</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">c_sd</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">n_pot0</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">n_pot1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">n_pot2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">n_pot3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">c_ef</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ef</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">-</span>
<span class="w">            </span><span class="p">((</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_pot0</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_pot1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="p">(</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">6</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_pot2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">9</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_pot3</span><span class="p">[</span><span class="mi">0</span><span class="p">])));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//compute_electric_field : iterates over cells</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ncell</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map1idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map2idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map3idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map4idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">iter</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>

<span class="w">    </span><span class="n">compute_ef_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_ef</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">12</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n_potential</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map1idx</span><span class="p">],</span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">n_potential</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map2idx</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n_potential</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map3idx</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n_potential</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map4idx</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, convert the loop to use the <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">compute_ef_kernel</span><span class="p">(</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">c_ef</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">c_sd</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">n_pot0</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">n_pot1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">n_pot2</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">n_pot3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">c_ef</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c_ef</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">-</span>
<span class="w">            </span><span class="p">((</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_pot0</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_pot1</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="p">(</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_pot2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">c_sd</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">n_pot3</span><span class="p">[</span><span class="mi">0</span><span class="p">])));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">opp_par_loop</span><span class="p">(</span><span class="n">compute_ef_kernel</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;compute_electric_field&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_ITERATE_ALL</span><span class="p">,</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">c_ef</span><span class="p">,</span><span class="w">                    </span><span class="n">OPP_RW</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">c_sd</span><span class="p">,</span><span class="w">                    </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_potential</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_potential</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_potential</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_potential</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_READ</span><span class="p">));</span>
</pre></div>
</div>
<p>Note in this case how the indirections are specified using the mapping declared as <code class="docutils literal notranslate"><span class="pre">opp_map</span></code> <code class="docutils literal notranslate"><span class="pre">c2n_map</span></code>, indicating the to-set index (2nd argument), and access mode <code class="docutils literal notranslate"><span class="pre">OPP_READ</span></code>.</p>
<p>That is, the thrid argument of the <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> is a read-only argument mapped from cells to nodes using the mapping at the 0th index of c2n_map (i.e. 1st mapping out of 4 nodes attached).
Likewise, the fourth argument of <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> is mapped from cells to nodes using the mapping at the 1st index of <code class="docutils literal notranslate"><span class="pre">c2n_map</span></code> (i.e. 2nd mapping out of 4 nodes attached) and so on.</p>
<p>Second, we use <code class="docutils literal notranslate"><span class="pre">calculate_new_pos_vel</span></code> calculation to showcase the particle set to mesh set mapping indirections.
Here we iterate over particles set, access cell electric fields through indirect accesses using <code class="docutils literal notranslate"><span class="pre">p2c_map</span></code>.
Note that one particle in FemPIC can be linked with only only one cell.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//calculate_new_pos_vel : iterates over cells</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nparticles</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">[</span><span class="n">iter</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">coef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CONST_charge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CONST_mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CONST_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">p_vel</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">coef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c_ef</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">dim</span><span class="p">]);</span>
<span class="w">        </span><span class="n">p_pos</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p_vel</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CONST_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Then, we outline the loop body and call it within the loop as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">calc_pos_vel_kernel</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">cell_ef</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">part_pos</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">part_vel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">coef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CONST_charge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CONST_mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CONST_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">part_vel</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">coef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cell_ef</span><span class="p">[</span><span class="n">dim</span><span class="p">]);</span>
<span class="w">        </span><span class="n">part_pos</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_vel</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">CONST_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//calculate_new_pos_vel : iterates over particles</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nparticles</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">[</span><span class="n">iter</span><span class="p">];</span>
<span class="w">    </span><span class="n">calc_pos_vel_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c_ef</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p_pos</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p_vel</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, convert the loop to use the <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">calc_pos_vel_kernel</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">cell_ef</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">part_pos</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">part_vel</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">coef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CONST_charge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">CONST_mass</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CONST_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">dim</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">part_vel</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="p">(</span><span class="n">coef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cell_ef</span><span class="p">[</span><span class="n">dim</span><span class="p">]);</span>
<span class="w">        </span><span class="n">part_pos</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_vel</span><span class="p">[</span><span class="n">dim</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">CONST_dt</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">opp_par_loop</span><span class="p">(</span><span class="n">calc_pos_vel_kernel</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;calculate_new_pos_vel&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_ITERATE_ALL</span><span class="p">,</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">c_ef</span><span class="p">,</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">p_pos</span><span class="p">,</span><span class="w">         </span><span class="n">OPP_WRITE</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">p_vel</span><span class="p">,</span><span class="w">         </span><span class="n">OPP_WRITE</span><span class="p">));</span>
</pre></div>
</div>
<p>Note in this case how the indirections are specified using the mapping declared as <code class="docutils literal notranslate"><span class="pre">opp_map</span></code> <code class="docutils literal notranslate"><span class="pre">p2c_map</span></code>, and access mode <code class="docutils literal notranslate"><span class="pre">OPP_READ</span></code>.</p>
<p>That is, the first argument of the <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> is a read-only argument mapped from particles to cells, however a mapping index is not required since always particles to cells mapping has a dimension of one.</p>
</section>
<section id="c-double-indirect-loop">
<h3>(c) Double Indirect loop<a class="headerlink" href="#c-double-indirect-loop" title="Link to this heading"></a></h3>
<p>There could be instances where double indirection is required.
For example in <code class="docutils literal notranslate"><span class="pre">deposit_charge_on_nodes</span></code>, we may need to deposit charge from particles to nodes, but from particles we have a single mapping towards the cells, with another mapping from cells to nodes.</p>
<p>Here we iterate over particles set, access node charge density through double-indirect accesses using <code class="docutils literal notranslate"><span class="pre">p2c_map</span></code> and <code class="docutils literal notranslate"><span class="pre">c2n_map</span></code>.
Note that one cell in FemPIC is linked with 4 surrounding nodes and <code class="docutils literal notranslate"><span class="pre">n_charge_den</span></code> has a dimension of one.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//deposit_charge_on_nodes : iterates over cells</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nparticles</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">[</span><span class="n">iter</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map1idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">p2c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map2idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">p2c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map3idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">p2c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map4idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">p2c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>

<span class="w">    </span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map1idx</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map2idx</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map3idx</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map4idx</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Similarly, we outline the loop body and call it within the loop as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dep_charge_kernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">part_lc</span><span class="p">,</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">node_charge_den0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">node_charge_den1</span><span class="p">,</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">node_charge_den2</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">node_charge_den3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">node_charge_den0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_lc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="n">node_charge_den1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_lc</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">node_charge_den2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_lc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">node_charge_den3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_lc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">//deposit_charge_on_nodes : iterates over cells</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nparticles</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">[</span><span class="n">iter</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map1idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">p2c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map2idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">p2c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map3idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">p2c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">map4idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">[</span><span class="n">p2c</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>

<span class="w">    </span><span class="n">dep_charge_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map1idx</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map2idx</span><span class="p">],</span>
<span class="w">        </span><span class="o">&amp;</span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map3idx</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">map4idx</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, convert the loop to use the <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dep_charge_kernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">part_lc</span><span class="p">,</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">node_charge_den0</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">node_charge_den1</span><span class="p">,</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">node_charge_den2</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">node_charge_den3</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="n">node_charge_den0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_lc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">    </span><span class="n">node_charge_den1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_lc</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">    </span><span class="n">node_charge_den2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_lc</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="w">    </span><span class="n">node_charge_den3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">part_lc</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">opp_par_loop</span><span class="p">(</span><span class="n">dep_charge_kernel</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;deposit_charge_on_nodes&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_ITERATE_ALL</span><span class="p">,</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">p_lc</span><span class="p">,</span><span class="w">                              </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_charge_den</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">,</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_INC</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_charge_den</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">,</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_INC</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_charge_den</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">,</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_INC</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_charge_den</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">c2n_map</span><span class="p">,</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_INC</span><span class="p">));</span>
</pre></div>
</div>
<p>Note in this case how the indirections are specified using the mapping declared using two maps <code class="docutils literal notranslate"><span class="pre">p2c_map</span></code> and <code class="docutils literal notranslate"><span class="pre">c2n_map</span></code>, indicating the to-set index (2nd argument), and access mode <code class="docutils literal notranslate"><span class="pre">OPP_INC</span></code>.</p>
<p>That is, the second argument of the <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> is an increment argument mapped from particles to cells and cells to nodes using the mapping at the 0th index of <code class="docutils literal notranslate"><span class="pre">c2n_map</span></code> (i.e. 1st mapping out of 4 nodes attached).
Likewise, the third argument of <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> is mapped from particles to cells and cells to nodes using the mapping at the 1st index of <code class="docutils literal notranslate"><span class="pre">c2n_map</span></code> (i.e. 2nd mapping out of 4 nodes attached) and so on.</p>
</section>
</section>
<section id="step-4-move-loop-opp-particle-move">
<h2>Step 4 - Move loop : <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code><a class="headerlink" href="#step-4-move-loop-opp-particle-move" title="Link to this heading"></a></h2>
<p>A key step in a PIC solver is the particle move.
Here we will first illustrate how a particle mover operates in an unstructured mesh environment.</p>
<p>The main idea of a particle mover is to search and position particles once it is moved to a new position under the influence of electric and magnetic fields.</p>
<p>The first strategy that we discuss here is named as <code class="docutils literal notranslate"><span class="pre">Multi-Hop</span> <span class="pre">(MH)</span></code>.
It loop over each particle and “track” its movement from cell to cell by computing the next probable cell.
This entails an inner loop per particle which will terminate when the final destination cell is reached.</p>
<a class="reference internal image-reference" href="_images/image_multi_hop.png"><img alt="_images/image_multi_hop.png" src="_images/image_multi_hop.png" style="height: 250px;" />
</a>
<p>To explain this, we use the FemPIC particle move routine.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//move_particles : iterates over cells</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nparticles</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">search_next_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">[</span><span class="n">iter</span><span class="p">];</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c2c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2c_map</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="p">];</span>

<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">coeff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">6.0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">c_volume</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="p">]);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coeff</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">c_det</span><span class="p">[</span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span>
<span class="w">                </span><span class="n">c_det</span><span class="p">[</span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_pos</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span>
<span class="w">                </span><span class="n">c_det</span><span class="p">[</span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_pos</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span>
<span class="w">                </span><span class="n">c_det</span><span class="p">[</span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_pos</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">||</span>
<span class="w">              </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">||</span>
<span class="w">              </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">||</span>
<span class="w">              </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// within current cell</span>
<span class="w">            </span><span class="n">search_next_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// outside the last known cell</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">min_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="kt">double</span><span class="w"> </span><span class="n">min_lc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">];</span>

<span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// find most negative weight</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_lc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                    </span><span class="n">min_lc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span><span class="p">];</span>
<span class="w">                    </span><span class="n">min_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c2c_map</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">min_i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// is there a neighbor in this direction?</span>
<span class="w">                </span><span class="n">p2c_map</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2c_map</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">min_i</span><span class="p">];</span>
<span class="w">                </span><span class="n">search_next_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// No neighbour cell to search next, particle out of domain,</span>
<span class="w">                </span><span class="c1">// Mark and remove from simulation!!!</span>
<span class="w">                </span><span class="n">p2c_map</span><span class="p">[</span><span class="n">iter</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">;</span>
<span class="w">                </span><span class="n">search_next_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">search_next_cell</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once this move routine is executed, there may be particles with <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code> p2c mapping, which means the data on all the particle dats related to that specific particle index are invalid.</p>
<p>One option is to fill these <code class="docutils literal notranslate"><span class="pre">holes</span></code> using valid particle data from the end of the array (we call it hole filling).</p>
<p>Another option is to sort all the particle arrays according to the p2c_map (desc), which will shift all particles with <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code> p2c mapping to shift to the end.
This will have benefits of better cache usage, since all particles that maps to the same cell index will be close to each other, however, do note that sorting particle dats follow its own performance overhead!</p>
<p>One other option is to shuffle the particles, while shifting the particles with <code class="docutils literal notranslate"><span class="pre">INT_MAX</span></code> p2c mapping to the end of the data structure.
The benefits of doing so in device implementations are elaborated in the Optimization section.</p>
<p>Similar to other parallel loops, we outline the loop body and call it within the loop as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">move_kernel</span><span class="p">(</span><span class="kt">bool</span><span class="o">&amp;</span><span class="w"> </span><span class="n">search_next_cell</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">c2c</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">point_pos</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">point_lc</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">cell_volume</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">cell_det</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">coeff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">6.0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">cell_volume</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">point_lc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coeff</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">cell_det</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span>
<span class="w">            </span><span class="n">cell_det</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">point_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="n">cell_det</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">point_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span>
<span class="w">            </span><span class="n">cell_det</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">point_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">point_lc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">||</span>
<span class="w">          </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">||</span>
<span class="w">          </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">||</span>
<span class="w">          </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// within the current cell</span>
<span class="w">        </span><span class="n">search_next_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// outside the last known cell</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">min_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">min_lc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// find most negative weight</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">point_lc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_lc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">min_lc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">min_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c2c</span><span class="p">[</span><span class="n">min_i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// is there a neighbor in this direction?</span>
<span class="w">        </span><span class="n">p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c2c</span><span class="p">[</span><span class="n">min_i</span><span class="p">];</span>
<span class="w">        </span><span class="n">search_next_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// No neighbour cell to search next, particle out of domain,</span>
<span class="w">        </span><span class="c1">// Mark and remove from simulation!!!</span>
<span class="w">        </span><span class="n">p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">;</span>
<span class="w">        </span><span class="n">search_next_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
<span class="c1">//move_particles : iterates over cells</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nparticles</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">search_next_cell</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2c_map</span><span class="p">[</span><span class="n">iter</span><span class="p">];</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">c2c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c2c_map</span><span class="p">[</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">]];</span>

<span class="w">        </span><span class="n">move_kernel</span><span class="p">(</span><span class="n">search_next_cell</span><span class="p">,</span><span class="w"> </span><span class="n">p2c</span><span class="p">,</span><span class="w"> </span><span class="n">c2c</span><span class="p">,</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">p_pos</span><span class="p">[</span><span class="mi">3</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">16</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span>
<span class="w">            </span><span class="o">&amp;</span><span class="n">c_volume</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">c_det</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]);</span>

<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">search_next_cell</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, convert the loop to use the <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code> API.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">move_kernel</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">point_pos</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="o">*</span><span class="w"> </span><span class="n">point_lc</span><span class="p">,</span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">cell_volume</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="o">*</span><span class="n">cell_det</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">coeff</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">6.0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">cell_volume</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                            </span><span class="c1">// &lt;- (1)</span>
<span class="w">        </span><span class="n">point_lc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">coeff</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">cell_det</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span>
<span class="w">            </span><span class="n">cell_det</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">point_pos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">+</span>
<span class="w">            </span><span class="n">cell_det</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">point_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span>
<span class="w">            </span><span class="n">cell_det</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">point_pos</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">point_lc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">||</span><span class="w">      </span><span class="c1">// &lt;- (2)</span>
<span class="w">          </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">||</span>
<span class="w">          </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="o">||</span>
<span class="w">          </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">1.0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// within the current cell</span>
<span class="w">        </span><span class="c1">// no additional computations in FemPIC          // &lt;- (3)</span>
<span class="w">        </span><span class="n">OPP_PARTICLE_MOVE_DONE</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// outside the last known cell</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">min_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">double</span><span class="w"> </span><span class="n">min_lc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_lc</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// find most negative weight</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">point_lc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_lc</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">min_lc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point_lc</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="n">min_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// is there a neighbor in this direction?</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opp_c2c</span><span class="p">[</span><span class="n">min_i</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">opp_p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_c2c</span><span class="p">[</span><span class="n">min_i</span><span class="p">];</span><span class="w">                     </span><span class="c1">// &lt;- (5)</span>
<span class="w">        </span><span class="n">OPP_PARTICLE_NEED_MOVE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">                                               </span><span class="c1">// &lt;- (4)</span>
<span class="w">        </span><span class="c1">// No neighbour cell to search next, particle out of domain,</span>
<span class="w">        </span><span class="c1">// Mark and remove from simulation!!!</span>
<span class="w">        </span><span class="n">opp_p2c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">;</span>
<span class="w">        </span><span class="n">OPP_PARTICLE_NEED_REMOVE</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="n">opp_particle_move</span><span class="p">(</span><span class="n">move_kernel</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;move&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="n">c2c_map</span><span class="p">,</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">,</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">p_pos</span><span class="p">,</span><span class="w">             </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">p_lc</span><span class="p">,</span><span class="w">              </span><span class="n">OPP_WRITE</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">c_volume</span><span class="p">,</span><span class="w"> </span><span class="n">p2c_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">c_det</span><span class="p">,</span><span class="w">    </span><span class="n">p2c_map</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_READ</span><span class="p">));</span>
</pre></div>
</div>
<p>Note how we have:</p>
<ul class="simple">
<li><p>indicated the elemental kernel <code class="docutils literal notranslate"><span class="pre">move_kernel</span></code> in the first argument to <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code> loop.</p></li>
<li><p>used particles_set as the iterating set and provided cell to cell mapping <code class="docutils literal notranslate"><span class="pre">c2c_map</span></code> and particle to cell mapping <code class="docutils literal notranslate"><span class="pre">p2c_map</span></code> as 4th and 5th arguments of the <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code> API call.</p></li>
<li><p>by providing <code class="docutils literal notranslate"><span class="pre">c2c_map</span></code> and <code class="docutils literal notranslate"><span class="pre">p2c_map</span></code>, they are accessed within the elemental kernel, using <code class="docutils literal notranslate"><span class="pre">opp_c2c</span></code> and <code class="docutils literal notranslate"><span class="pre">opp_p2c</span></code> pointers, without the need to explicitly pass as kernel arguments.</p></li>
<li><p>direct, indirect, or double indirect mappings can be provided as opp_arg_dats similar to <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> (double indirection is not present in this example).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">OPP_PARTICLE_MOVE_DONE</span></code>, <code class="docutils literal notranslate"><span class="pre">OPP_PARTICLE_NEED_MOVE</span></code> and <code class="docutils literal notranslate"><span class="pre">OPP_PARTICLE_NEED_REMOVE</span></code> pre-processor statements can be used to indicate the code-generator about the particle move status.</p></li>
</ul>
<p>To summarize, the elemental kernel over all particles will require:</p>
<ol class="arabic simple">
<li><p>specifying computations to be carried out for each mesh element, e.g., cells, along the path of the particle, until its final destination cell.</p></li>
<li><p>a method to identify if the particle has reached its final mesh cell.</p></li>
<li><p>computations to be carried out at the final destination mesh cell.</p></li>
<li><p>actions to be carry out if the particle has moved out of the mesh domain.</p></li>
<li><p>calculate the next most probable cell index to search.</p></li>
</ol>
<p>In additon to above, a user can provide a code-block to be executed only once per particle (during the first iteration of the do while loop) using the pre-processor directive <code class="docutils literal notranslate"><span class="pre">OPP_DO_ONCE</span></code>.
This will be beneficial if the move kernel is required to include the code to calculate position and velocity (rather than a separate <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> like in FemPIC).</p>
<p>Additionally, if required deposit charge on nodes can be done at the place indicated by (3) in the elemental kernel.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">move_kernel</span><span class="p">(</span><span class="n">args</span><span class="w"> </span><span class="p">...)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">OPP_DO_ONCE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="cm">/* any computation that should get executed only once */</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* computation per mesh elment for particle */</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="cm">/* check condition for final destination */</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="cm">/* if final destination element - final computation*/</span>
<span class="w">    </span><span class="n">OPP_PARTICLE_DONE_MOVE</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="cm">/* else if out of domain*/</span>
<span class="w">    </span><span class="n">OPP_PARTICLE_NEED_REMOVE</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="w">    </span><span class="cm">/* else - not final destination element - calculate next cell &amp; move further*/</span>
<span class="w">    </span><span class="n">OPP_PARTICLE_NEED_MOVE</span><span class="p">;</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Once <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code> is executed, all the particles that were marked as <code class="docutils literal notranslate"><span class="pre">OPP_PARTICLE_NEED_REMOVE</span></code> will get removed according to the routine requested by the user in the config file (hole-fill, sort, shuffle or a mix of these).
More details on configs will be in a later section.</p>
<p>In addition, in an MPI and/or GPU target, all the communications and synchronizations will occur within <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code> without any user intervention.</p>
<p>Eventhough, <code class="docutils literal notranslate"><span class="pre">Multi-hop</span></code> approach performs when particles move to closer cells, its performance is degraded when particles are moved to a faraway cell, making it to hop for long.</p>
<p>To address this issue of fast moving particles, OP-PIC incorporates a <code class="docutils literal notranslate"><span class="pre">Direct-hop</span> <span class="pre">(DH)</span></code> mechanism, where the particles are moved directly to a cell closer to the final destination, and then switches to <code class="docutils literal notranslate"><span class="pre">multi-hop</span></code> mode to move it to the correct final destination.</p>
<p>Note that, allthough, direct_hop reduces unnecessary computations and communications significantly, a higher memory footprint is required for bookkeeping.</p>
<a class="reference internal image-reference" href="_images/image_direct_hop.png"><img alt="_images/image_direct_hop.png" src="_images/image_direct_hop.png" style="height: 250px;" />
</a>
<p>This mechanism can only be used in algorithms when it is not required to deposit contributions to all the passing cells during the particle movement.
Hence, for the applications we tested, <code class="docutils literal notranslate"><span class="pre">DH</span></code> can be directly used for electro-static PIC codes, while electo-magnetic PIC codes require deposition of current to each passing cell.</p>
<p>To enable <code class="docutils literal notranslate"><span class="pre">DH</span></code>, the user should call the API <code class="docutils literal notranslate"><span class="pre">opp_init_direct_hop</span></code>, with the grid spacing (resolution) required in <code class="docutils literal notranslate"><span class="pre">DH</span></code> search scheme, dimension of the simulation (1D, 2D or 3D), a global cell index <code class="docutils literal notranslate"><span class="pre">opp_dat</span></code> (mainly required to translate cell indices in an MPI code simulation) and a <code class="docutils literal notranslate"><span class="pre">opp::BoundingBox</span></code> indicating the simulation boundaries.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">opp_init_direct_hop</span><span class="p">(</span><span class="n">grid_spacing</span><span class="p">,</span><span class="w"> </span><span class="n">DIM</span><span class="p">,</span><span class="w"> </span><span class="n">c_gbl_id</span><span class="p">,</span><span class="w"> </span><span class="n">bounding_box</span><span class="p">);</span>
</pre></div>
</div>
<p>The bounding box can be created by providing a mesh dat that has its positions (like node positions) using:</p>
<p><code class="docutils literal notranslate"><span class="pre">opp::BoundingBox(const</span> <span class="pre">opp_dat</span> <span class="pre">pos_dat,</span> <span class="pre">int</span> <span class="pre">dim)</span></code></p>
<p>or simply by providing the calculated minimum and maximum domain coordinates using:</p>
<p><code class="docutils literal notranslate"><span class="pre">opp::BoundingBox(int</span> <span class="pre">dim,</span> <span class="pre">opp_point</span> <span class="pre">minCoordinate,</span> <span class="pre">opp_point</span> <span class="pre">maxCoordinate)</span></code>.</p>
<p>Once <code class="docutils literal notranslate"><span class="pre">opp_init_direct_hop</span></code> API is called, the code-generator will extract the required information from <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code> API call, generate the initializing code for the additional data structures required for <code class="docutils literal notranslate"><span class="pre">DH</span></code> and change the internal do while loop to incorporate the additional DH algorithms.</p>
<p>However, even with an application having <code class="docutils literal notranslate"><span class="pre">DH</span></code> code generated and compiled, a user may wish to disable <code class="docutils literal notranslate"><span class="pre">DH</span></code> during runtime with no additional performance degradation to <code class="docutils literal notranslate"><span class="pre">MH</span></code>, using a config (discussed later).</p>
</section>
<section id="step-5-particle-injections">
<h2>Step 5 - Particle injections<a class="headerlink" href="#step-5-particle-injections" title="Link to this heading"></a></h2>
<p>In PIC simulations, particles can be initialized during setup stage, or can be injected during the simulation as an additional routine.</p>
<p>This particle injections imposes performance implications, since frequent reallocations takes time, especially in device code.
To avoid this, OP-PIC introduces a new config <code class="docutils literal notranslate"><span class="pre">opp_allocation_multiple</span></code> (double) to pre-allocate the set with a multiple of its intended allocation size.</p>
<p>For example, if <code class="docutils literal notranslate"><span class="pre">opp_allocation_multiple=10</span></code> and if the <code class="docutils literal notranslate"><span class="pre">parts_to_insert=5,000</span></code>, it will allocate space for 50,000 particles, making <code class="docutils literal notranslate"><span class="pre">particle_set-&gt;set_capacity</span></code> to 50,000 while maintaining <code class="docutils literal notranslate"><span class="pre">particle_set-&gt;size</span></code> at 5,000.</p>
<p>Hence during the injection of the second iteration of the main loop (assume <code class="docutils literal notranslate"><span class="pre">parts_to_insert=5,000</span></code> again), it will simply make the <code class="docutils literal notranslate"><span class="pre">particle_set-&gt;size</span></code> to 10,000.</p>
<section id="a-allocate-space-for-particles">
<h3>(a) Allocate space for particles<a class="headerlink" href="#a-allocate-space-for-particles" title="Link to this heading"></a></h3>
<p>To allocate new particles, the API <code class="docutils literal notranslate"><span class="pre">opp_increase_particle_count</span></code> can be used. This will require the particle set to allocate and number of particles to insert.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">opp_increase_particle_count</span><span class="p">(</span><span class="n">opp_set</span><span class="w"> </span><span class="n">p_set</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">parts_to_insert</span><span class="p">)</span>
</pre></div>
</div>
<p>Another API to inject particles is by, that requires particle distribution <code class="docutils literal notranslate"><span class="pre">opp_dat</span></code>.
The part_dist dat should include the particle distribution per cell, and the <code class="docutils literal notranslate"><span class="pre">p2c_map</span></code> of the particle set will get enriched with the appropriate cell index.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="n">opp_inc_part_count_with_distribution</span><span class="p">(</span><span class="n">opp_set</span><span class="w"> </span><span class="n">p_set</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">parts_to_insert</span><span class="p">,</span><span class="w"> </span><span class="n">opp_dat</span><span class="w"> </span><span class="n">part_dist</span><span class="p">)</span>
</pre></div>
</div>
<p>As an example, consider a mesh with 10 cells:</p>
<table class="docutils align-default">
<tbody>
<tr class="row-odd"><td><p>cell index</p></td>
<td><p>0</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
<td><p>8</p></td>
<td><p>9</p></td>
</tr>
<tr class="row-even"><td><p>inject particles per cell</p></td>
<td><p>10</p></td>
<td><p>11</p></td>
<td><p>10</p></td>
<td><p>9</p></td>
<td><p>7</p></td>
<td><p>7</p></td>
<td><p>10</p></td>
<td><p>12</p></td>
<td><p>9</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>part_dist opp_dat</p></td>
<td><p>10</p></td>
<td><p>21</p></td>
<td><p>31</p></td>
<td><p>40</p></td>
<td><p>47</p></td>
<td><p>54</p></td>
<td><p>64</p></td>
<td><p>76</p></td>
<td><p>85</p></td>
<td><p>95</p></td>
</tr>
</tbody>
</table>
<p>Since the mesh is unstructured mesh with different volumes, particles per cell can vary and part_dist <code class="docutils literal notranslate"><span class="pre">opp_dat</span></code> should have the particle counts as above (own particles + all particles prior to current cell index).</p>
<p>Providing this part_dist to <code class="docutils literal notranslate"><span class="pre">opp_inc_part_count_with_distribution</span></code> API call will enrich the <code class="docutils literal notranslate"><span class="pre">p2c_map</span></code> of first 10 particles with value 0, next 11 particles with value 1, following 10 particles wit value 2 and so on.</p>
<p>This will be beneficial in some cases where cell specific values need to be pre-known prior initializing particles (e.g. to get <code class="docutils literal notranslate"><span class="pre">cell_ef</span></code> to enrich <code class="docutils literal notranslate"><span class="pre">p_vel</span></code>).</p>
</section>
<section id="b-initialize-the-injected-particles">
<h3>(b) Initialize the injected particles<a class="headerlink" href="#b-initialize-the-injected-particles" title="Link to this heading"></a></h3>
<p>In order to initialize the injected particles, we can use <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> with iteration type of <code class="docutils literal notranslate"><span class="pre">OPP_ITERATE_INJECTED</span></code>.
This will allow iterating only the particles that are newly injected.</p>
<p>However, once an <code class="docutils literal notranslate"><span class="pre">opp_move_particle</span></code> loop is executed, these particles will no longer be newly injected, hence a loop with <code class="docutils literal notranslate"><span class="pre">OPP_ITERATE_INJECTED</span></code> will not iterate any.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">opp_par_loop</span><span class="p">(</span><span class="n">inject_ions_kernel</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;inject_ions&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_ITERATE_INJECTED</span><span class="p">,</span>
<span class="w">    </span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="w"> </span><span class="p">...</span>
<span class="p">);</span>
</pre></div>
</div>
</section>
</section>
<section id="step-6-global-reductions">
<h2>Step 6 - Global reductions<a class="headerlink" href="#step-6-global-reductions" title="Link to this heading"></a></h2>
<p>At this stage almost all the remaining loops can be converted to the OP-PIC API. Only the final loop <code class="docutils literal notranslate"><span class="pre">get_final_max_values</span></code> needs special handling due to its global reduction to get the max value of node charge density and node potential.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//get_final_max_values : iterates over nodes</span>
<span class="kt">double</span><span class="w"> </span><span class="n">max_n_charge_den</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">max_n_pot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnodes</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">max_n_charge_den</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">]),</span><span class="w"> </span><span class="n">max_n_charge_den</span><span class="p">);</span>
<span class="w">    </span><span class="n">max_n_pot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX</span><span class="p">(</span><span class="n">n_pot</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span><span class="w"> </span><span class="n">max_n_pot</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here, the global variable <code class="docutils literal notranslate"><span class="pre">max_n_charge_den</span></code> and <code class="docutils literal notranslate"><span class="pre">max_n_pot</span></code> are used as reduction variables. The kernel can be outlined as follows:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_final_max_values_kernel</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">OPP_REAL</span><span class="o">*</span><span class="w"> </span><span class="n">n_charge_den</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_REAL</span><span class="o">*</span><span class="w"> </span><span class="n">max_n_charge_den</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">OPP_REAL</span><span class="o">*</span><span class="w"> </span><span class="n">n_pot</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_REAL</span><span class="o">*</span><span class="w"> </span><span class="n">max_n_pot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">max_n_charge_den</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">]),</span><span class="w"> </span><span class="n">max_n_charge_den</span><span class="p">);</span>
<span class="w">    </span><span class="n">max_n_pot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX</span><span class="p">(</span><span class="n">n_pot</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span><span class="w"> </span><span class="n">max_n_pot</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">double</span><span class="w"> </span><span class="n">max_n_charge_den</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">max_n_pot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="c1">//get_final_max_values : iterates over nodes</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">iter</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">nnodes</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">iter</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">get_final_max_values_kernel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max_n_charge_den</span><span class="p">,</span>
<span class="w">                                </span><span class="o">&amp;</span><span class="n">n_pot</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span><span class="w"> </span><span class="o">&amp;</span><span class="n">max_n_pot</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, convert the loop to use the <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> API:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="c1">//outlined elemental kernel</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">get_final_max_values_kernel</span><span class="p">(</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">OPP_REAL</span><span class="o">*</span><span class="w"> </span><span class="n">n_charge_den</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_REAL</span><span class="o">*</span><span class="w"> </span><span class="n">max_n_charge_den</span><span class="p">,</span>
<span class="w">    </span><span class="k">const</span><span class="w"> </span><span class="n">OPP_REAL</span><span class="o">*</span><span class="w"> </span><span class="n">n_pot</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_REAL</span><span class="o">*</span><span class="w"> </span><span class="n">max_n_pot</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">max_n_charge_den</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">n_charge_den</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">]),</span><span class="w"> </span><span class="n">max_n_charge_den</span><span class="p">);</span>
<span class="w">    </span><span class="n">max_n_pot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MAX</span><span class="p">(</span><span class="n">n_pot</span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iter</span><span class="p">],</span><span class="w"> </span><span class="n">max_n_pot</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">double</span><span class="w"> </span><span class="n">max_n_charge_den</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span><span class="n">max_n_pot</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="n">opp_par_loop</span><span class="p">(</span><span class="n">get_final_max_values_kernel</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;get_final_max_values&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_ITERATE_ALL</span><span class="p">,</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_charge_den</span><span class="p">,</span><span class="w">                   </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_gbl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max_n_charge_den</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;double&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_MAX</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_dat</span><span class="p">(</span><span class="n">n_potential</span><span class="p">,</span><span class="w">                    </span><span class="n">OPP_READ</span><span class="p">),</span>
<span class="w">    </span><span class="n">opp_arg_gbl</span><span class="p">(</span><span class="o">&amp;</span><span class="n">max_n_pot</span><span class="p">,</span><span class="w">        </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;double&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">OPP_MAX</span><span class="p">));</span>
</pre></div>
</div>
<p>This kind of global reductions can be done in both <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> and <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code> loops.</p>
<p>At this point, all the loops have been converted to use <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> and <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code> APIs.
When developing applications for performance, you should consider freeing the initial memory allocated immediately after the relevant <code class="docutils literal notranslate"><span class="pre">opp_decl_map</span></code> and <code class="docutils literal notranslate"><span class="pre">opp_decl_dat</span></code> calls.
In FemPIC, we are using <code class="docutils literal notranslate"><span class="pre">m-&gt;DeleteValues()</span></code> to free the initializing data structures.</p>
<p>In the next step we avoid freeing such “application developer allocated” memory by using HDF5 file I/O so that mesh data is directly read from file to OP-PIC allocated internal memory.</p>
</section>
<section id="step-7-handing-it-all-to-op-pic">
<h2>Step 7 - Handing it all to OP-PIC<a class="headerlink" href="#step-7-handing-it-all-to-op-pic" title="Link to this heading"></a></h2>
<p>Once the developer sequential version has been created and the numerical output validates the application can be prepared to obtain a developer distributed memory parallel version.
This step can be completed to obtain a parallel executable that works with distributed memory MPI.</p>
<section id="a-distributing-data-over-mpi-ranks">
<h3>(a) Distributing data over MPI ranks<a class="headerlink" href="#a-distributing-data-over-mpi-ranks" title="Link to this heading"></a></h3>
<p>One way is to load the mesh into the OPP_ROOT (rank 0) and then distribute over MPI ranks.
For an example, <code class="docutils literal notranslate"><span class="pre">check</span> <span class="pre">distribute_data_over_ranks</span></code> function in <code class="docutils literal notranslate"><span class="pre">OP-PIC/app_fempic/fempic_misc_mesh_loader.h</span></code>.
This approach limits scaling when a large mesh is used (may take time to load data to one rank and distribute) and possibly run out of memory.</p>
<p>The other approach is to use HDF5 files to load data using HDF5 derivatives of the <code class="docutils literal notranslate"><span class="pre">opp_decl_set,</span> <span class="pre">opp_decl_particle_set,</span> <span class="pre">opp_decl_map</span> <span class="pre">and</span> <span class="pre">opp_decl_dat</span></code> API calls.</p>
<p>See <code class="docutils literal notranslate"><span class="pre">OP-PIC/app_fempic/fempic_hdf5.cpp</span></code> for a complete example.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="n">opp_set</span><span class="w"> </span><span class="n">node_set</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_set_hdf5</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mesh_nodes&quot;</span><span class="p">);</span>
<span class="n">opp_set</span><span class="w"> </span><span class="n">cell_set</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_set_hdf5</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;mesh_cells&quot;</span><span class="p">);</span>
<span class="n">opp_set</span><span class="w"> </span><span class="n">iface_set</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_set_hdf5</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;inlet_faces_cells&quot;</span><span class="p">);</span>
<span class="n">opp_set</span><span class="w"> </span><span class="n">particle_set</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_particle_set_hdf5</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;particles&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cell_set</span><span class="p">);</span>
<span class="n">opp_set</span><span class="w"> </span><span class="n">dummy_part_set</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_particle_set_hdf5</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dummy particles&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cell_set</span><span class="p">);</span>

<span class="n">opp_map</span><span class="w"> </span><span class="n">c2n_map</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map_hdf5</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w">  </span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_v_n_map&quot;</span><span class="p">);</span>
<span class="n">opp_map</span><span class="w"> </span><span class="n">c2c_map</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map_hdf5</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w">  </span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_v_c_map&quot;</span><span class="p">);</span>
<span class="n">opp_map</span><span class="w"> </span><span class="n">if2c_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map_hdf5</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;if_v_c_map&quot;</span><span class="p">);</span>
<span class="n">opp_map</span><span class="w"> </span><span class="n">if2n_map</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map_hdf5</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;if_v_n_map&quot;</span><span class="p">);</span>

<span class="n">opp_map</span><span class="w"> </span><span class="n">p2c_map</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_map</span><span class="p">(</span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;part_mesh_rel&quot;</span><span class="p">);</span>

<span class="n">opp_dat</span><span class="w"> </span><span class="n">c_det</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_det&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">c_volume</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_volume&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">c_ef</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_ef&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">c_sd</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_shape_deri&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">c_gbl_id</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_INT</span><span class="p">,</span><span class="w">  </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_gbl_id&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">c_colors</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_INT</span><span class="p">,</span><span class="w">  </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_colors&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">c_centroids</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;c_centroids&quot;</span><span class="p">);</span>

<span class="n">opp_dat</span><span class="w"> </span><span class="n">n_volume</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;n_vol&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">n_potential</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;n_potential&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">n_charge_den</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;n_charge_den&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">n_pos</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;n_pos&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">n_type</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_INT</span><span class="p">,</span><span class="w">  </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;n_type&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">n_bnd_pot</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">node_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;n_bnd_pot&quot;</span><span class="p">);</span>

<span class="n">opp_dat</span><span class="w"> </span><span class="n">if_v_norm</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;iface_v_norm&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">if_u_norm</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;iface_u_norm&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">if_norm</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;iface_norm&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">if_area</span><span class="w">    </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;iface_area&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">if_distrib</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">  </span><span class="n">DT_INT</span><span class="p">,</span><span class="w">  </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;iface_dist&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">if_n_pos</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">iface_set</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;iface_n_pos&quot;</span><span class="p">);</span>

<span class="n">opp_dat</span><span class="w"> </span><span class="n">p_pos</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;part_position&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">p_vel</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;part_velocity&quot;</span><span class="p">);</span>
<span class="n">opp_dat</span><span class="w"> </span><span class="n">p_lc</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">particle_set</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;part_lc&quot;</span><span class="p">);</span>

<span class="n">opp_dat</span><span class="w"> </span><span class="n">dp_rand</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp_decl_dat_hdf5</span><span class="p">(</span><span class="n">dummy_part_set</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">DT_REAL</span><span class="p">,</span><span class="w"> </span><span class="n">file_name</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;dummy_part_rand&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Note here that we assume that the mesh is already available as an <code class="docutils literal notranslate"><span class="pre">HDF5</span></code> file and the name can be obtained as a config.
(See the <code class="docutils literal notranslate"><span class="pre">OP-PIC/app_handcoded/app_fempic_opphc/fempic_convert_hdf5.cpp</span></code> utility application to understand how we can create an <code class="docutils literal notranslate"><span class="pre">HDF5</span></code> file to be compatible with the OP-PIC API for FemPIC starting from mesh data defined in a text file.)</p>
<p>When the application has been switched to use the <code class="docutils literal notranslate"><span class="pre">HDF5</span></code> API calls, manually allocated memory for the mesh elements can be removed.
Additionally all <code class="docutils literal notranslate"><span class="pre">printf</span></code> statements should use <code class="docutils literal notranslate"><span class="pre">opp_printf</span></code> which will add details such as the MPI rank and main loop iteration count that this print statement is invoked.
<code class="docutils literal notranslate"><span class="pre">OPP_RUN_ON_ROOT()</span></code> can be used to run only on root.
We can also use timers, utilizing <code class="docutils literal notranslate"><span class="pre">opp_profiler-&gt;start(&quot;name&quot;)</span></code> and <code class="docutils literal notranslate"><span class="pre">opp_profiler-&gt;end(&quot;name&quot;)</span></code>, which will capture the time spent between these two calls and log it once the application calls <code class="docutils literal notranslate"><span class="pre">opp_exit()</span></code>.</p>
</section>
<section id="b-partitioning-data-over-mpi-ranks">
<h3>(b) Partitioning data over MPI ranks<a class="headerlink" href="#b-partitioning-data-over-mpi-ranks" title="Link to this heading"></a></h3>
<p>Add the OP-PIC partitioner call <code class="docutils literal notranslate"><span class="pre">opp_partition</span></code> to the code in order to signal to the MPI back-end, the point in the program that all mesh data have been defined and mesh can be partitioned and MPI halos can be created.
Even in the sequential execution this can be scoped between <code class="docutils literal notranslate"><span class="pre">ifdef</span></code> to avoid compilation issues.</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="p">...</span>
<span class="n">opp_decl_const</span><span class="o">&lt;</span><span class="n">OPP_REAL</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ONE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">wall_potential</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;CONST_wall_potential&quot;</span><span class="p">);</span>

<span class="cp">#ifdef USE_MPI</span>
<span class="w">    </span><span class="n">fempic_color_block</span><span class="p">(</span><span class="n">c_colors</span><span class="p">,</span><span class="w"> </span><span class="n">c_centroids</span><span class="p">,</span><span class="w"> </span><span class="n">if_n_pos</span><span class="p">,</span><span class="w"> </span><span class="n">if2n_map</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// opp_partition(std::string(&quot;PARMETIS_KWAY&quot;), cell_set, c2n_map);</span>
<span class="w">    </span><span class="c1">// opp_partition(std::string(&quot;PARMETIS_GEOM&quot;), iface_set, nullptr, if_n_pos);</span>
<span class="w">    </span><span class="n">opp_partition</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;EXTERNAL&quot;</span><span class="p">),</span><span class="w"> </span><span class="n">cell_set</span><span class="p">,</span><span class="w"> </span><span class="k">nullptr</span><span class="p">,</span><span class="w"> </span><span class="n">c_colors</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">...</span>
<span class="p">...</span>
</pre></div>
</div>
<p>See the API documentation for partitioner options.</p>
<p>In this case a special custom partitioning scheme is used to minimize particle communications.
That is done by the enrichment of <code class="docutils literal notranslate"><span class="pre">c_colors</span></code> within a user written <code class="docutils literal notranslate"><span class="pre">fempic_color_block</span></code> function in <code class="docutils literal notranslate"><span class="pre">OP-PIC/app_fempic/fempic_misc_mesh_colour.h</span></code>.</p>
</section>
</section>
<section id="step-8-code-generation">
<h2>Step 8 - Code generation<a class="headerlink" href="#step-8-code-generation" title="Link to this heading"></a></h2>
<p>Now its time to generate the code for parallel versions.
First we should move the elemental kernels to header files so that after the code generation the modified main application will not have the same elemental kernel definitions.
This is only required since the code-generator removes the <code class="docutils literal notranslate"><span class="pre">CONST_</span></code> global variables from the main c++ file (however, commenting a single line of code in code-generator will allow writing elemental kernels in the same c++ file).</p>
<p>Additionally, FemPIC requires a files solver that uses linear sparse matrix solving, hence we have implemented it as a separate PETSc based solver that can be found at:</p>
<p><code class="docutils literal notranslate"><span class="pre">OP-PIC/app_fempic/field_solver/</span></code></p>
<p>The complete regular and the <code class="docutils literal notranslate"><span class="pre">HDF5</span></code> FemPIC applications can be found at <code class="docutils literal notranslate"><span class="pre">OP-PIC/app_fempic/</span></code> which can be independently code generated using the below.</p>
<p>In general the below command can be used to code-generate.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3<span class="w"> </span><span class="nv">$OPP_TRANSLATOR</span><span class="w"> </span>-v<span class="w"> </span>-I<span class="nv">$OPP_PATH</span>/include/<span class="w"> </span>--file_paths<span class="w"> </span>&lt;application_cpp_file&gt;
</pre></div>
</div>
<p>Specifically, for regular OP-PIC application without HDF5, use:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3<span class="w"> </span><span class="nv">$OPP_TRANSLATOR</span><span class="w"> </span>-v<span class="w"> </span>-I<span class="nv">$OPP_PATH</span>/include/<span class="w"> </span>--file_paths<span class="w"> </span>fempic.cpp
</pre></div>
</div>
<p>If HDF5 is required, invoke the command:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>python3<span class="w"> </span><span class="nv">$OPP_TRANSLATOR</span><span class="w"> </span>-v<span class="w"> </span>-I<span class="nv">$OPP_PATH</span>/include/<span class="w"> </span>--file_paths<span class="w"> </span>fempic_hdf5.cpp
</pre></div>
</div>
<p>Once the code-generator is invoked, a <code class="docutils literal notranslate"><span class="pre">fempic_opp.cpp</span></code> or <code class="docutils literal notranslate"><span class="pre">fempic_hdf5_opp.cpp</span></code> file and <code class="docutils literal notranslate"><span class="pre">seq</span></code>, <code class="docutils literal notranslate"><span class="pre">omp</span></code>, <code class="docutils literal notranslate"><span class="pre">mpi</span></code>, <code class="docutils literal notranslate"><span class="pre">cuda</span></code> and <code class="docutils literal notranslate"><span class="pre">hip</span></code> folders will be created,
including a <code class="docutils literal notranslate"><span class="pre">opp_kernels.&lt;cpp|cu&gt;</span></code> file and a loop kernel header file per unique <code class="docutils literal notranslate"><span class="pre">opp_par_loop</span></code> or <code class="docutils literal notranslate"><span class="pre">opp_particle_move</span></code> loop per folder.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="api.html" class="btn btn-neutral float-left" title="OP-PIC C++ API" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>